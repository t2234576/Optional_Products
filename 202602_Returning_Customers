-- Use CREATE OR REPLACE TEMPORARY TABLE if your SQL environment supports it, 
-- or just CREATE OR REPLACE TABLE to make it a permanent analytical base.

CREATE OR REPLACE TABLE optional_product_journey_2025 AS

WITH Full_History_With_Lag AS (
    -- Step 1: Calculate the entire chronological sequence dynamically for all time
    SELECT 
        uai_id,
        thread_acct_key,
        contr_date,
        
        -- 1. Flag if THIS loan has an OP
        CASE WHEN (COALESCE(IS_SCL_NET_SOLD, 0) + COALESCE(IS_SCA_NET_SOLD, 0) + 
                   COALESCE(IS_IUI_NET_SOLD, 0) + COALESCE(IS_GAP_NET_SOLD, 0) + 
                   COALESCE(IS_AUT_NET_SOLD, 0) + COALESCE(IS_HA_NET_SOLD, 0) + 
                   COALESCE(IS_ATL_NET_SOLD, 0) + COALESCE(IS_DIP_NET_SOLD, 0) + 
                   COALESCE(IS_SSG_NET_SOLD, 0)) > 0 
        THEN 1 ELSE 0 END AS Has_OP_Current,

        -- 2. Look back at the PREVIOUS loan in the thread and grab its OP Flag
        LAG(
            CASE WHEN (COALESCE(IS_SCL_NET_SOLD, 0) + COALESCE(IS_SCA_NET_SOLD, 0) + 
                       COALESCE(IS_IUI_NET_SOLD, 0) + COALESCE(IS_GAP_NET_SOLD, 0) + 
                       COALESCE(IS_AUT_NET_SOLD, 0) + COALESCE(IS_HA_NET_SOLD, 0) + 
                       COALESCE(IS_ATL_NET_SOLD, 0) + COALESCE(IS_DIP_NET_SOLD, 0) + 
                       COALESCE(IS_SSG_NET_SOLD, 0)) > 0 
            THEN 1 ELSE 0 END
        ) OVER(PARTITION BY thread_acct_key ORDER BY contr_date ASC) AS Has_OP_Previous,

        -- 3. Number the loans (1 = Their very first loan ever)
        ROW_NUMBER() OVER(PARTITION BY thread_acct_key ORDER BY contr_date ASC) AS Life_Seq

    FROM optional_product_master_full
),

Loan_Level_Logic AS (
    -- Step 2: Assign the Loan-Level Journey Bucket
    SELECT 
        uai_id,
        CASE 
            WHEN Life_Seq = 1 AND Has_OP_Current = 0 THEN '1. Net New - Missed'
            WHEN Life_Seq = 1 AND Has_OP_Current = 1 THEN '2. Net New - Acquired'
            WHEN Life_Seq > 1 AND Has_OP_Previous = 0 AND Has_OP_Current = 1 THEN '3. Returning - Convert (Win-Back/Upsell)'
            WHEN Life_Seq > 1 AND Has_OP_Previous = 1 AND Has_OP_Current = 1 THEN '4. Returning - Loyalist (Retained)'
            WHEN Life_Seq > 1 AND Has_OP_Previous = 1 AND Has_OP_Current = 0 THEN '5. Returning - Churner (Leakage)'
            WHEN Life_Seq > 1 AND Has_OP_Previous = 0 AND Has_OP_Current = 0 THEN '6. Returning - Hard No (Consistent)'
        END AS Loan_Level_Bucket
    FROM Full_History_With_Lag
),

Customer_Level_Pre2025 AS (
    -- Step 3: Establish the historical baseline per customer
    SELECT 
        thread_acct_key,
        MIN(EXTRACT(YEAR FROM contr_date)) AS First_Loan_Year,
        MAX(CASE 
            WHEN EXTRACT(YEAR FROM contr_date) < 2025 AND 
                 (COALESCE(IS_SCL_NET_SOLD, 0) + COALESCE(IS_SCA_NET_SOLD, 0) + 
                  COALESCE(IS_IUI_NET_SOLD, 0) + COALESCE(IS_GAP_NET_SOLD, 0) + 
                  COALESCE(IS_AUT_NET_SOLD, 0) + COALESCE(IS_HA_NET_SOLD, 0) + 
                  COALESCE(IS_ATL_NET_SOLD, 0) + COALESCE(IS_DIP_NET_SOLD, 0) + 
                  COALESCE(IS_SSG_NET_SOLD, 0)) > 0 
            THEN 1 ELSE 0 
        END) AS Had_OP_Before_2025
    FROM optional_product_master_full
    GROUP BY 1
),

Customer_Level_Final_2025 AS (
    -- Step 4: Identify the final OP state of 2025 per customer
    SELECT 
        thread_acct_key,
        Has_OP_Current AS Final_2025_Has_OP
    FROM (
        SELECT 
            thread_acct_key,
            Has_OP_Current,
            ROW_NUMBER() OVER(PARTITION BY thread_acct_key ORDER BY contr_date DESC) as Reverse_2025_Seq
        FROM Full_History_With_Lag
        WHERE EXTRACT(YEAR FROM contr_date) = 2025
    )
    WHERE Reverse_2025_Seq = 1
),

Customer_Level_Logic AS (
    -- Step 5: Assign the Customer-Level Journey Bucket
    SELECT 
        F.thread_acct_key,
        CASE 
            WHEN P.First_Loan_Year = 2025 AND F.Final_2025_Has_OP = 0 THEN '1. Net New - Missed'
            WHEN P.First_Loan_Year = 2025 AND F.Final_2025_Has_OP = 1 THEN '2. Net New - Acquired'
            WHEN P.First_Loan_Year < 2025 AND P.Had_OP_Before_2025 = 0 AND F.Final_2025_Has_OP = 1 THEN '3. Returning - Convert (Win-Back/Upsell)'
            WHEN P.First_Loan_Year < 2025 AND P.Had_OP_Before_2025 = 1 AND F.Final_2025_Has_OP = 1 THEN '4. Returning - Loyalist (Retained)'
            WHEN P.First_Loan_Year < 2025 AND P.Had_OP_Before_2025 = 1 AND F.Final_2025_Has_OP = 0 THEN '5. Returning - Churner (Leakage)'
            WHEN P.First_Loan_Year < 2025 AND P.Had_OP_Before_2025 = 0 AND F.Final_2025_Has_OP = 0 THEN '6. Returning - Hard No (Consistent)'
        END AS Customer_Level_Bucket
    FROM Customer_Level_Final_2025 F
    JOIN Customer_Level_Pre2025 P ON F.thread_acct_key = P.thread_acct_key
)

-- Step 6: Join everything back to your original 2025 Master Table
SELECT 
    m25.*, -- This keeps all your original columns (State, Channels, Product Flags, etc.)
    LL.Loan_Level_Bucket,
    CL.Customer_Level_Bucket

FROM optional_product_master m25
-- Join the Loan Level Flag using the unique application ID
LEFT JOIN Loan_Level_Logic LL ON m25.uai_id = LL.uai_id
-- Join the Customer Level Flag using the thread key (this broadcasts their final year-end status to all their 2025 loans)
LEFT JOIN Customer_Level_Logic CL ON m25.thread_acct_key = CL.thread_acct_key;

-- ====================================================================
-- At Loan Level (Transactional view)
-- Captures CUST_TYPE and intra-year changes
-- ====================================================================

SELECT 
    CUST_TYPE,
    CASE 
        WHEN UPPER(TRIM(CLOSING_METHOD)) IN ('KIOSK', 'BRANCH', 'IN-PERSON') THEN 'BRANCH'
        WHEN UPPER(TRIM(CLOSING_METHOD)) IN ('ONLINE', 'REMOTE', 'DIGITAL', 'INTERNET') THEN 'ONLINE'
        ELSE 'OTHER' 
    END AS Closing_Channel,
    Loan_Level_Bucket AS Customer_Journey_Bucket,
    COUNT(uai_id) AS Loan_Volume

FROM optional_product_journey_2025
GROUP BY 1, 2, 3
ORDER BY 1, 2, 3;

-- ====================================================================
-- At Customer Level (Unique People view)
-- Evaluates final 2025 status and ignores intra-year noise
-- ====================================================================

SELECT 
    Customer_Level_Bucket,
    COUNT(DISTINCT thread_acct_key) AS Unique_Customers,
    COUNT(uai_id) AS Total_2025_Loans_Generated

FROM optional_product_journey_2025
GROUP BY 1
ORDER BY 1 ASC;
